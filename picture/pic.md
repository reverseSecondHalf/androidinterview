# 1. 图片加载框架
## 1.1. fresco/glide
https://juejin.cn/post/6844903986412126216  
三级缓存机制
## 1.2. coil 
轻量级协程图片库
# 2. [图片格式](https://juejin.cn/post/6912217043009798157)
jpg vs png vs webp vs heic  
gif vs webp  
svg  
jpg或者png格式改为webp，webp改为heic带来的带宽提升。
# 3. 图片监控  
## 3.1. 大图监控  

可以参考这个文章的5.4 https://juejin.cn/post/7074762489736478757
### 3.1.1. 图片框架侧的监控
### 3.1.2. ImageView的监控
## 3.2. 空窗率监控（相对、绝对）  


# 4. 图片本地压缩  
无侵入式图片压缩：  
参见这篇文章的5.3.2：https://juejin.cn/post/7074762489736478757  
参见这个开源库：https://github.com/smallSohoSolo/McImage  

# 5. 图片渲染优化
比如某些场景大图无法支持小的，但是渲染的区域又远小于图片实际大小，可以做下采样处理，提高性能。
# 图片圆角方案
这里有列出：https://blog.51cto.com/u_11359966/5760224
# 图片在内存里占据大小的计算方式
1. 图片本身的大小和它占用内存的大小没有什么关系。
2. 图片占用内存的计算公式：分辨率 * 像素点大小，也就是 长 * 宽 * 像素点大小，像素点大小是根据加载方式来定的，例如 ARGB_8888 占 4 个字节，RGB_565 占 2 个字节。
3. 图片的来源是 android 的资源文件夹：这种情况下，系统会根据设备的 dpi 值，以及 资源目录的 dpi 值做一次分辨率转换，转换的规律就是：图片宽 * (设备dpi / 对应资源目录 dpi)  * 图片高 * (设备 dpi / 对应资源目录dpi)。如果不对图片进行优化处理，那么 Android 系统就会根据图片不同来源决定是否需要对原图分辨率进行转换再加载进内存。
4. 其他图片如，assets，磁盘，流等图片都是按照原图分辨率来计算大小。